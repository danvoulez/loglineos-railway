contract logline.api.gateway version "1.0.0" {
  meta: {
    id: "logline://contracts/api.gateway";
    description: "LogLine API Gateway - High Availability FastAPI with @handle identity management";
    author: "LogLine Engineering";
    build_date: "2025-09-23";
    tenant_scope: "global";
  }

  // API server lifecycle state machine
  state machine ServerState {
    Initializing -> Healthy on event("health_check_passed");
    Healthy -> Degraded on event("error_threshold_exceeded");
    Degraded -> Healthy on event("recovery_successful");
    Healthy -> Maintenance on event("maintenance_requested");
    Maintenance -> Healthy on event("maintenance_complete");
  }

  // Core API endpoints
  api {
    // Health and status endpoints
    endpoint "/health" {
      method: "GET";
      description: "Health check with database connectivity";
      response_schema: {
        ok: boolean,
        db: string,
        timestamp: timestamp,
        version: string
      }
    }

    endpoint "/healthz" {
      method: "GET"; 
      description: "Kubernetes-style health check";
      response_schema: {
        ok: boolean,
        db: string
      }
    }

    // LogLine ID management endpoints
    endpoint "/id/create" {
      method: "POST";
      description: "Create new LogLine ID (@handle)";
      auth_required: true;
      request_schema: {
        handle: string,
        entity_type: "person" | "object" | "contract" | "rule" | "timeline" | "app" | "flow",
        metadata: object
      }
      response_schema: {
        logline_id: string,
        handle: string,
        created_at: timestamp
      }
    }

    endpoint "/id/resolve/{handle}" {
      method: "GET";
      description: "Resolve @handle to LogLine ID";
      path_params: {
        handle: string
      }
      response_schema: {
        found: boolean,
        logline_id: string,
        entity_type: string,
        metadata: object
      }
    }

    // Onboarding endpoints
    endpoint "/onboard/ghost" {
      method: "POST";
      description: "Create ghost session for anonymous onboarding";
      request_schema: {
        device_id: string,
        metadata: object
      }
      response_schema: {
        session_id: string,
        ghost_handle: string,
        expires_at: timestamp
      }
    }

    endpoint "/onboard/transition" {
      method: "POST";
      description: "Transition ghost to verified identity";
      auth_required: true;
      request_schema: {
        session_id: string,
        verification_data: object,
        target_handle: string
      }
      response_schema: {
        success: boolean,
        logline_id: string,
        handle: string
      }
    }
  }

  // Startup sequence
  on start:
    emit_span "api_gateway_starting" { 
      timestamp: now(),
      version: "1.0.0",
      mode: "production"
    };
    
    // Initialize database connection
    let db_result = call "database.connect" with { 
      url: env("DATABASE_URL"),
      pool_size: 10,
      timeout_seconds: 30
    };
    
    ensure db_result.connected == true or fail "Database connection failed";
    
    // Initialize health monitoring
    spawn "health_monitor" with {
      check_interval_seconds: 30,
      error_threshold: 5,
      recovery_threshold: 3
    };
    
    // Start API server
    spawn "fastapi_server" with {
      host: env("HOST") ?? "0.0.0.0",
      port: env("PORT") ?? 3000,
      workers: env("WORKERS") ?? 1
    };
    
    emit_span "api_gateway_ready" {
      timestamp: now(),
      host: env("HOST"),
      port: env("PORT"),
      database_connected: true
    };
    
    transition ServerState to Healthy;

  // Health monitoring
  on event "health_check":
    let db_status = call "database.ping" with { timeout_seconds: 5 };
    let memory_usage = call "system.memory_usage";
    let cpu_usage = call "system.cpu_usage";
    
    if db_status.ok && memory_usage < 80 && cpu_usage < 90 {
      emit_span "health_check_passed" {
        timestamp: now(),
        db_latency_ms: db_status.latency,
        memory_percent: memory_usage,
        cpu_percent: cpu_usage
      };
      emit event("health_check_passed");
    } else {
      emit_span "health_check_failed" {
        timestamp: now(),
        db_ok: db_status.ok,
        memory_percent: memory_usage,
        cpu_percent: cpu_usage,
        error: "Health check thresholds exceeded"
      };
      emit event("error_threshold_exceeded");
    }

  // Request handling with spans
  on event "api_request":
    let start_time = now();
    let request_id = uuid();
    
    emit_span "api_request_start" {
      request_id: request_id,
      method: payload.method,
      path: payload.path,
      user_agent: payload.headers.user_agent,
      ip: payload.client_ip,
      timestamp: start_time
    };
    
    // Route request to appropriate handler
    route payload to handler;
    
    let end_time = now();
    let duration_ms = (end_time - start_time) * 1000;
    
    emit_span "api_request_complete" {
      request_id: request_id,
      method: payload.method,
      path: payload.path,
      status_code: handler.response.status,
      duration_ms: duration_ms,
      timestamp: end_time
    };

  // Error handling and recovery
  on error as err:
    emit_span "api_error" {
      timestamp: now(),
      error_type: err.type,
      error_message: err.message,
      stack_trace: err.stack,
      request_context: last_request()
    };
    
    // Implement circuit breaker pattern
    if err.type == "database_connection_lost" {
      call "database.reconnect" with { retry_attempts: 3, backoff_seconds: 5 };
    }
    
    if err.critical {
      transition ServerState to Degraded;
      emit event("error_threshold_exceeded");
    }

  // Graceful shutdown
  on shutdown:
    emit_span "api_gateway_shutting_down" { timestamp: now() };
    
    call "database.close_connections";
    call "fastapi_server.graceful_shutdown" with { timeout_seconds: 30 };
    
    emit_span "api_gateway_shutdown_complete" { timestamp: now() };

  // Metrics and monitoring
  metrics {
    counter "api_requests_total" {
      labels: ["method", "path", "status_code"]
    }
    
    histogram "api_request_duration_seconds" {
      labels: ["method", "path"]
      buckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]
    }
    
    gauge "active_connections" {
      description: "Number of active database connections"
    }
    
    gauge "server_health_score" {
      description: "Overall server health (0-100)"
    }
  }
}